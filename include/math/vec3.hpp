#ifndef VEC3_HPP
#define VEC3_HPP

#include "geometry.hpp"

struct vec2;

//----------------------------------------------------------------------------------------------------------------------
/// \struct A 3d vector, holds an x and y component, and has overloaded operators to make the syntax nicer.
//----------------------------------------------------------------------------------------------------------------------
struct vec3
{
    //----------------------------------------------------------------------------------------------------------------------
    /// \brief X component.
    //----------------------------------------------------------------------------------------------------------------------
    float m_x;

    //----------------------------------------------------------------------------------------------------------------------
    /// \brief Y component.
    //----------------------------------------------------------------------------------------------------------------------
    float m_y;

    //----------------------------------------------------------------------------------------------------------------------
    /// \brief Z component.
    //----------------------------------------------------------------------------------------------------------------------
    float m_z;

    //----------------------------------------------------------------------------------------------------------------------
    /// \brief In-place operators.
    //----------------------------------------------------------------------------------------------------------------------
    vec3& operator=(const vec3 &_rhs) { m_x = _rhs.m_x; m_y = _rhs.m_y; m_z = _rhs.m_z; return *this; }
    vec3& operator+=(vec3 _rhs) { m_x += _rhs.m_x; m_y += _rhs.m_y; m_z += _rhs.m_z; return *this; }
    vec3& operator-=(vec3 _rhs) { m_x -= _rhs.m_x; m_y -= _rhs.m_y; m_z -= _rhs.m_z; return *this; }
    vec3& operator-=(float &_rhs) { m_x -= _rhs; m_y -= _rhs; m_z -= _rhs; return *this; }
    vec3& operator*=(const float &_rhs) { m_x *= _rhs; m_y *= _rhs; m_z *= _rhs; return *this; }
    vec3& operator/=(float &_rhs) { m_x /= _rhs; m_y /= _rhs; m_z /= _rhs; return *this; }

    vec3():
        m_x(0.0f),
        m_y(0.0f),
        m_z(0.0f)
    {}

    vec3(const float _f):
        m_x(_f),
        m_y(_f),
        m_z(_f)
    {}

    vec3(const float _x, const float _y, const float _z):
        m_x(_x),
        m_y(_y),
        m_z(_z)
    {}
};


//----------------------------------------------------------------------------------------------------------------------
/// \brief More operators.
//----------------------------------------------------------------------------------------------------------------------
vec3 operator +(const vec3 &_lhs, const vec3 &_rhs);
vec3 operator +(const vec3 &_lhs, const float &_rhs);
vec3 operator +(const float &_lhs, const vec3 &_rhs);
vec3 operator -(const vec3 &_lhs, const vec3 &_rhs);
vec3 operator -(const vec3 &_lhs);
vec3 operator *(const vec3 &_lhs, const vec3 &_rhs);
vec3 operator *(const vec3 &_lhs, const float &_rhs);
vec3 operator *(const float &_lhs, const vec3 &_rhs);
vec3 operator /(const vec3 &_lhs, const vec3 &_rhs);
vec3 operator /(const vec3 &_lhs, const float &_rhs);
vec3 operator ^(const vec3 &_lhs, const float &_rhs);
bool operator ==(const vec3 &_lhs, const vec3 &_rhs);


//----------------------------------------------------------------------------------------------------------------------
/// \brief Sums the components of a vector.
//----------------------------------------------------------------------------------------------------------------------

float sum(vec3 _vec);
float asum(vec3 _vec);

//----------------------------------------------------------------------------------------------------------------------
/// \brief 2d and 3d cross-products.
//----------------------------------------------------------------------------------------------------------------------
vec3 crossProd(const vec3 A, const vec3 B);

//----------------------------------------------------------------------------------------------------------------------
/// \brief Returns the length of a vector. Where possible, use magns().
//----------------------------------------------------------------------------------------------------------------------
float mag(const vec3 vec);

//----------------------------------------------------------------------------------------------------------------------
/// \brief Returns the squared length of a vector.
//----------------------------------------------------------------------------------------------------------------------
float magns(const vec3 vec);

//----------------------------------------------------------------------------------------------------------------------
/// \brief Returns the reciprocal of the length of a vector.
//----------------------------------------------------------------------------------------------------------------------
float invMag(const vec3 vec);

//----------------------------------------------------------------------------------------------------------------------
/// \brief Normalises a given vector.
//----------------------------------------------------------------------------------------------------------------------
vec3 unit(const vec3 vec);

vec3 clamp(const vec3 _in, vec3 _min, vec3 _max);

//----------------------------------------------------------------------------------------------------------------------
/// \brief Returns the dot of two vectors.
//----------------------------------------------------------------------------------------------------------------------
float dot(const vec3 A, const vec3 B);

//----------------------------------------------------------------------------------------------------------------------
/// \brief Returns the dot of two vectors, which are first normalised.
//----------------------------------------------------------------------------------------------------------------------
float udot(const vec2 A, const vec2 B);
float udot(const vec3 A, const vec3 B);

//----------------------------------------------------------------------------------------------------------------------
/// \brief Given a point p1 and a gradients m1, and the general point p2, will find the point on p1 + t(m1) closest to p2.
/// \param _p1 line point, _m1 gradient, _p2 general point.
//----------------------------------------------------------------------------------------------------------------------
vec3 closest(const vec3 p1, const vec3 m1, const vec3 p2);

//----------------------------------------------------------------------------------------------------------------------
/// \brief Converts a 2d vector to 3d and vice versa.
//----------------------------------------------------------------------------------------------------------------------
vec2 tovec2(const vec3 vec);


#endif
