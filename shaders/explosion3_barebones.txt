#define SMOOTHNESS 0.03


const int ITERATIONS = 30;
const float STEP = 0.02;
const float DITHER = 0.2;
const float DURATION = 2.0;
const float PI = 3.14159265;

float sq(float _n)
{
	return _n * _n;    
}

vec3 grayscale(vec3 _v)
{
	return vec3((_v.x + _v.y + _v.z) / 3.0);      
}

float hash( float n )
{
	return fract(cos(n)*41415.92653);	//https://www.shadertoy.com/view/4sXGRM
    //return fract(sin(n)*753.5453123);	//https://www.shadertoy.com/view/4sfGzS
}

float noise( in vec3 x )
{
    vec3 f = fract(x);
    vec3 p = x - f; // this avoids the floor() but doesnt affect performance for me.
    f = f*f*(3.0-2.0*f);	
    float n = p.x + p.y*157.0 + 113.0*p.z;
    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),
                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),
               mix(mix( hash(n+113.0), hash(n+114.0),f.x),
                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);
}

float fbm(vec3 x)
{
    float r = 0.0;
    float w = 1.0, s = 1.0;
    for (int i=0; i<5; i++)
    {
        w *= 0.5;
        s *= 2.0;
        r += w * noise(s * x);
    }
    return r;
}

float sphere(vec3 p, float r)
{
    return length(p) - r;
}

vec4 scene(vec3 pos, vec3 dir, out float dist)
{
    float debugTime = fract(iGlobalTime / DURATION) * DURATION;
    float nTime = clamp(sqrt(debugTime / DURATION), 0.0, 1.0);
    float rnTime = 1.0 - nTime;
    
    //Main radius
    float rad1 = 0.5 * nTime;//0.4;
    //Smoke radius
    float rad2 = 0.9 * nTime - 0.2;//0.35;
    //Radius used to interpolate from fire to smoke
    float rad0 = 0.6 * nTime;
    
    float d = sphere(pos, rad2);
    d -= rad0 * fbm(pos * 2.0 + iGlobalTime * 0.1);
    dist = d;
    
    vec4 color = vec4(0.0);
    float r = length(pos) / rad0;
    
    color.a = smoothstep(1.0, 0.0, clamp(d / SMOOTHNESS, 0.0, 1.0));
    color.a *= smoothstep(1.0, 0.0, clamp((r - 1.3) * 2., 0., 1.));
    color.a *= clamp(5.0 * rnTime, 0.0, 1.0);
    
    //Base colour
    color.rgb = 1.2 * mix(vec3(1.0,0.95,0.2), vec3(1.0,0.35,0.0), clamp((r - 1.1) * 3.0, 0.0, 1.0));
    
    //Fire->Smoke interpolation
    color.rgb = mix(color.rgb, grayscale(color.rgb) * 0.25, clamp((rad2 - rad0) * 15.0, 0.0, 1.0));

    //Ambient smoke
    color.rgb = mix(color.rgb, vec3(0.95,0.95,0.97)*0.25, clamp((r - 1.3) * 3.0, 0., 1.));
    
    return color;
}

vec3 render(vec3 eye, vec3 dir, vec2 fragCoord)
{
    vec4 color = vec4(0.0);
    
    vec3 pos = eye + dir * DITHER;
    
    for (int i=0; i<ITERATIONS; i++)
    {
        if (color.a > 0.99) continue;
        
        float dist;
        vec4 d = scene(pos, dir, dist);
        d.rgb *= d.a;
        color += d * (1.0 - color.a);
     
        pos += dir * max(STEP, dist * 0.5);
    }
    
    color.rgb += vec3(0.1 * vec3(1.0,0.5,0.1)) * (1.0 - color.a);
    
    return clamp(color.rgb, 0.0, 1.0);
}

vec3 lookAtDir(vec2 uv, vec3 up)
{
    vec3 f = vec3(0.,0.,-1.);
    vec3 r = vec3(1., 0., 0.);
    vec3 u = vec3(0., 1., 0.);
    //vec3 u = normalize(vec3(-1./sqrt(2.0),-1./sqrt(2.0), 0.));
    
    return normalize(f + (uv.x * r + uv.y * u));
    //return normalize(vec3(0.0, 10.0, 0.0));
}

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    vec2 uv = fragCoord.xy / iResolution.xy;
    uv = uv * 2.0 - 1.0;
    uv.x *= iResolution.x / iResolution.y;
    
    vec3 eye = vec3(0.0, 0.0, 1.5);
    vec3 dir = lookAtDir(uv, vec3(0.0, 1.0, 0.0));
    	
    vec3 color = render(eye, dir, fragCoord);
    
    fragColor = vec4(color, 1.0);
}